MachineDictionary.registerCasings();

let bitmap = android.graphics.BitmapFactory.decodeFile(__dir__ + "gui/BronzeAlloySmelterPocket.png");
MachineDictionary.registerSteamMachine({ name: "alloy_smelter", 
type: MachineDictionary.PROCESSING, 
hull: "brick_hull",
tier: [0, 1],
recipes: new RecipeMap(1, 2, 1, 1)
}, {
     standart: {
          header: {
               text: {
                    text: "Alloy Smelter"
               },
               color: android.graphics.Color.rgb(225, 119, 6)
          },
          inventory: {
               standart: true
          },
          background: {
               color: android.graphics.Color.rgb(225, 119, 6)
          },
          minHeight: 600
     },
     params: {
          textures: {
               /*slot: "thaum_slot",
               invSlot: "thaum_inv_slot",
               selection: "thaum_selection",
               closeButton: "thaum_close_button_up",
               closeButton2: "thaum_close_button_down",
               frame: "thaum_frame_default"*/
          }
     },
     drawing: [
         {type: "bitmap", bitmap: "BronzeAlloySmelterPocket", x: 1000 / 2 - bitmap.getWidth(), y: 40, width: bitmap.getWidth() * 3, height: bitmap.getHeight() * 3}
     ],
     elements: {
       "energySlot": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 237, y: 226, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true},
       "input0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 102, y: 112, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true},
       "input1": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 156, y: 
112, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true},
    "scale": {type: "scale", x: 1000 / 2 - bitmap.getWidth() + 225, y: 112, direction: 0, bitmap: "furnace_process", scale: 2, value: 0},
        "output0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 318, y: 112, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true, isValid: function(){return false;}},
     },
});
MachineDictionary.registerSteamMachine({
    name: "furnace",
    type: MachineDictionary.PROCESSING,
    hull: "brick_hull",
    tier: [0, 1],
    recipes: RecipeDictionary.RECIPE_FURNACE_MAP
}, {
     standart: {
          header: {
               text: {
                    text: "Furnace"
               },
               color: android.graphics.Color.rgb(225, 119, 6)
          },
          inventory: {
               standart: true
          },
          background: {
               color: android.graphics.Color.rgb(225, 119, 6)
          },
          minHeight: 600
     },
     params: {
          textures: {
               /*slot: "thaum_slot",
               invSlot: "thaum_inv_slot",
               selection: "thaum_selection",
               closeButton: "thaum_close_button_up",
               closeButton2: "thaum_close_button_down",
               frame: "thaum_frame_default"*/
          }
     },
     drawing: [
         {type: "bitmap", bitmap: "BronzeFurnacePocket", x: 1000 / 2 - bitmap.getWidth(), y: 40, width: bitmap.getWidth() * 3, height: bitmap.getHeight() * 3}
     ],
     elements: {
       "energySlot": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 237, y: 226, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true},
       "input0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 156, y: 112, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true},
    "scale": {type: "scale", x: 1000 / 2 - bitmap.getWidth() + 225, y: 112, direction: 0, bitmap: "furnace_process", scale: 2, value: 0},
        "output0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 318, y: 112, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true, isValid: function(){return false;}},
     },
});
MachineDictionary.registerSteamMachine({
    name: "macerator",
    type: MachineDictionary.PROCESSING,
    hull: "bronze_hull",
    tier: [0, 1],
    recipes: new RecipeMap(1, 1, 1, 1)
}, {
     standart: {
          header: {
               text: {
                    text: "Macerator"
               },
               color: android.graphics.Color.rgb(225, 119, 6)
          },
          inventory: {
               standart: true
          },
          background: {
               color: android.graphics.Color.rgb(225, 119, 6)
          },
          minHeight: 600
     },
     params: {
          textures: {
               /*slot: "thaum_slot",
               invSlot: "thaum_inv_slot",
               selection: "thaum_selection",
               closeButton: "thaum_close_button_up",
               closeButton2: "thaum_close_button_down",
               frame: "thaum_frame_default"*/
          }
     },
     drawing: [
         {type: "bitmap", bitmap: "BronzeMaceratorPocket", x: 1000 / 2 - bitmap.getWidth(), y: 40, width: bitmap.getWidth() * 3, height: bitmap.getHeight() * 3}
     ],
     elements: {
       "energySlot": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 237, y: 226, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true},
       "input0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 156, y: 112, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true},
    "scale": {type: "scale", x: 1000 / 2 - bitmap.getWidth() + 225, y: 112, direction: 0, bitmap: "furnace_process", scale: 2, value: 0},
        "output0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 318, y: 112, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true, isValid: function(){return false;}},
     },
});
MachineDictionary.registerSteamMachine({
    name: "extractor",
    type: MachineDictionary.PROCESSING,
    hull: "hull",
    tier: [0, 1],
    recipes: new RecipeMap(1, 1, 1, 1),
}, {
     standart: {
          header: {
               text: {
                    text: "Extractor"
               },
               color: android.graphics.Color.rgb(225, 119, 6)
          },
          inventory: {
               standart: true
          },
          background: {
               color: android.graphics.Color.rgb(225, 119, 6)
          },
          minHeight: 600
     },
     params: {
          textures: {
               /*slot: "thaum_slot",
               invSlot: "thaum_inv_slot",
               selection: "thaum_selection",
               closeButton: "thaum_close_button_up",
               closeButton2: "thaum_close_button_down",
               frame: "thaum_frame_default"*/
          }
     },
     drawing: [
         {type: "bitmap", bitmap: "BronzeExtractorPocket", x: 1000 / 2 - bitmap.getWidth(), y: 40, width: bitmap.getWidth() * 3, height: bitmap.getHeight() * 3}
     ],
     elements: {
       "energySlot": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 237, y: 226, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true},
       "input0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 156, y: 112, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true},
    "scale": {type: "scale", x: 1000 / 2 - bitmap.getWidth() + 225, y: 112, direction: 0, bitmap: "furnace_process", scale: 2, value: 0},
        "output0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 318, y: 112, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true, isValid: function(){return false;}},
     },
});
MachineDictionary.registerSteamMachine({
    name: "compressor",
    type: MachineDictionary.PROCESSING,
    hull: "hull",
    tier: [0, 1],
    recipes: new RecipeMap(1, 1, 1, 1)
}, {
     standart: {
          header: {
               text: {
                    text: "Compressor"
               },
               color: android.graphics.Color.rgb(225, 119, 6)
          },
          inventory: {
               standart: true
          },
          background: {
               color: android.graphics.Color.rgb(225, 119, 6)
          },
          minHeight: 600
     },
     params: {
          textures: {
               /*slot: "thaum_slot",
               invSlot: "thaum_inv_slot",
               selection: "thaum_selection",
               closeButton: "thaum_close_button_up",
               closeButton2: "thaum_close_button_down",
               frame: "thaum_frame_default"*/
          }
     },
     drawing: [
         {type: "bitmap", bitmap: "BronzeCompressorPocket", x: 1000 / 2 - bitmap.getWidth(), y: 40, width: bitmap.getWidth() * 3, height: bitmap.getHeight() * 3}
     ],
     elements: {
       "energySlot": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 237, y: 226, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true},
       "input0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 156, y: 112, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true},
    "scale": {type: "scale", x: 1000 / 2 - bitmap.getWidth() + 225, y: 112, direction: 0, bitmap: "furnace_process", scale: 2, value: 0},
        "output0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 318, y: 112, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true, isValid: function(){return false;}},
     },
});
MachineDictionary.registerSteamMachine({
    name: "hammer",
    type: MachineDictionary.PROCESSING,
    hull: "hull",
    tier: [0, 1],
    recipes: new RecipeMap(1, 1, 1, 1),
}, {
     standart: {
          header: {
               text: {
                    text: "Forge hammer"
               },
               color: android.graphics.Color.rgb(225, 119, 6)
          },
          inventory: {
               standart: true
          },
          background: {
               color: android.graphics.Color.rgb(225, 119, 6)
          },
          minHeight: 600
     },
     params: {
          textures: {
               /*slot: "thaum_slot",
               invSlot: "thaum_inv_slot",
               selection: "thaum_selection",
               closeButton: "thaum_close_button_up",
               closeButton2: "thaum_close_button_down",
               frame: "thaum_frame_default"*/
          }
     },
     drawing: [
         {type: "bitmap", bitmap: "BronzeHammerPocket", x: 1000 / 2 - bitmap.getWidth(), y: 40, width: bitmap.getWidth() * 3, height: bitmap.getHeight() * 3}
     ],
     elements: {
       "energySlot": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 237, y: 226, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true},
       "input0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 156, y: 112, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true},
    "scale": {type: "scale", x: 1000 / 2 - bitmap.getWidth() + 219, y: 112, direction: 0, bitmap: "furnace_process", scale: 2, value: 0},
        "output0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 318, y: 112, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true, isValid: function(){return false;}},
     },
});

MachineDictionary.registerSteamMachine({
    name: "boiler",
    type: MachineDictionary.GENERATOR,
    hull: "brick_hull",
    tier: [0, 1],
    recipes: new FuelMap(1, 1),
}, {
     standart: {
          header: {
               text: {
                    text: "Bronze boiler"
               },
               color: android.graphics.Color.rgb(225, 119, 6)
          },
          inventory: {
               standart: true
          },
          background: {
               color: android.graphics.Color.rgb(225, 119, 6)
          },
          minHeight: 600
     },
     params: {
          textures: {
               /*slot: "thaum_slot",
               invSlot: "thaum_inv_slot",
               selection: "thaum_selection",
               closeButton: "thaum_close_button_up",
               closeButton2: "thaum_close_button_down",
               frame: "thaum_frame_default"*/
          }
     },
     drawing: [
         {type: "bitmap", bitmap: "BronzeBoilerPocket", x: 1000 / 2 - bitmap.getWidth(), y: 40, width: bitmap.getWidth() * 3, height: bitmap.getHeight() * 3}
     ],
     elements: {
        "inputCan0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 129, y: 115, size: 54, bitmap: "slot", needClean: true,isTransparentBackground: true},
       "coal0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 345, y: 223, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true},
    "scale": {type: "scale", x: 1000 / 2 - bitmap.getWidth() + 345, y: 169, direction: 1, bitmap: "bronze_boiler_process", scale: 3, value: 0},
        "ash0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 345, y: 115, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true, isValid: function(){return false;}},
        "outputCan0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 129, y: 223, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true, isValid: function(){return false;}},
        "waterScale": {type: "scale", x: 1000 / 2 - bitmap.getWidth() + 210, y: 115, direction: 1, bitmap: "water_scale", scale: 3, value: 0},
        "steamScale": {type: "scale", x: 1000 / 2 - bitmap.getWidth() + 249, y: 115, direction: 1, bitmap: "steam_scale", scale: 3, value: 0},
        "heatScale": {type: "scale", x: 1000 / 2 - bitmap.getWidth() + 288, y: 115, direction: 1, bitmap: "heat_scale", scale: 3, value: 0},
     },
});

MachineDictionary.registerSteamMachine({
    name: "solar_boiler",
    type: MachineDictionary.GENERATOR,
    hull: "brick_hull",
    tier: [0],
    recipes: new FuelMap(0, 0),
}, {
     standart: {
          header: {
               text: {
                    text: "Solar boiler"
               },
               color: android.graphics.Color.rgb(225, 119, 6)
          },
          inventory: {
               standart: true
          },
          background: {
               color: android.graphics.Color.rgb(225, 119, 6)
          },
          minHeight: 600
     },
     params: {
          textures: {
               /*slot: "thaum_slot",
               invSlot: "thaum_inv_slot",
               selection: "thaum_selection",
               closeButton: "thaum_close_button_up",
               closeButton2: "thaum_close_button_down",
               frame: "thaum_frame_default"*/
          }
     },
     drawing: [
         {type: "bitmap", bitmap: "SolarBoilerPocket", x: 1000 / 2 - bitmap.getWidth(), y: 40, width: bitmap.getWidth() * 3, height: bitmap.getHeight() * 3}
     ],
     elements: {
       "inputCan0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 129, y: 115, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true},
    "scale": {type: "scale", x: 1000 / 2 - bitmap.getWidth() + 345, y: 169, direction: 0, bitmap: "furnace_process", scale: 2, value: 0},
        "outputCan0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 129, y: 223, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true, isValid: function(){return false;}},
             "waterScale": {type: "scale", x: 1000 / 2 - bitmap.getWidth() + 210, y: 115, direction: 1, bitmap: "water_scale", scale: 3, value: 0},
        "steamScale": {type: "scale", x: 1000 / 2 - bitmap.getWidth() + 249, y: 115, direction: 1, bitmap: "steam_scale", scale: 3, value: 0},
        "heatScale": {type: "scale", x: 1000 / 2 - bitmap.getWidth() + 288, y: 115, direction: 1, bitmap: "heat_scale", scale: 3, value: 0},
     },
});


/*MachineDictionary.registerSteamMachine("alloy_smelter", 1, 2, 1, MachineDictionary.PROCESSING, {
    name: "alloy_smelter",
    type: MachineDictionary.PROCESSING,
    inputSlots: 2, 
    outputSlots: 1,
}, {
     standart: {
          header: {
               text: {
                    text: "Alloy Smelter"
               },
               color: android.graphics.Color.rgb(225, 119, 6)
          },
          inventory: {
               standart: true
          },
          background: {
               color: android.graphics.Color.rgb(225, 119, 6)
          },
          minHeight: 600
     },
     params: {
          textures: {
               /*slot: "thaum_slot",
               invSlot: "thaum_inv_slot",
               selection: "thaum_selection",
               closeButton: "thaum_close_button_up",
               closeButton2: "thaum_close_button_down",
               frame: "thaum_frame_default"
          }
     },
     drawing: [
         {type: "bitmap", bitmap: "SteelAlloySmelterPocket", x: 1000 / 2 - bitmap.getWidth(), y: 40, width: bitmap.getWidth() * 3, height: bitmap.getHeight() * 3}
     ],
     elements: {
       "energySlot": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 237, y: 226, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true},
       "input0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 102, y: 112, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true},
       "input1": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 156, y: 
112, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true},
    "scale": {type: "scale", x: 1000 / 2 - bitmap.getWidth() + 225, y: 112, direction: 0, bitmap: "furnace_process", scale: 2, value: 0},
        "output0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 318, y: 112, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true},
     },
});*/
MachineDictionary.registerSteamMachine({
    name: "lava_boiler",
    type: MachineDictionary.GENERATOR,
    hull: "brick_hull",
    tier: [1],
    recipes: new FuelMap(1, 1),
}, {
     standart: {
          header: {
               text: {
                    text: "Lava boiler"
               },
               color: android.graphics.Color.rgb(225, 119, 6)
          },
          inventory: {
               standart: true
          },
          background: {
               color: android.graphics.Color.rgb(225, 119, 6)
          },
          minHeight: 600
     },
     params: {
          textures: {
               /*slot: "thaum_slot",
               invSlot: "thaum_inv_slot",
               selection: "thaum_selection",
               closeButton: "thaum_close_button_up",
               closeButton2: "thaum_close_button_down",
               frame: "thaum_frame_default"*/
          }
     },
     drawing: [
         {type: "bitmap", bitmap: "LavaBoilerPocket", x: 1000 / 2 - bitmap.getWidth(), y: 40, width: bitmap.getWidth() * 3, height: bitmap.getHeight() * 3}
     ],
     elements: {
       "energySlot": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 237, y: 226, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true},
           "inputCan0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 102, y: 112, size: 54, bitmap: "slot", needClean: true,isTransparentBackground: true},
       "coal0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 102, y: 112, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true},
    "scale": {type: "scale", x: 1000 / 2 - bitmap.getWidth() + 225, y: 112, direction: 0, bitmap: "furnace_process", scale: 2, value: 0},
        "ash0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 318, y: 112, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true},
        "output0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 318, y: 112, size: 54, bitmap: "slot", needClean: true, isTransparentBackground: true, isValid: function(){return false;}},
     },
});
//MachineDictionary.addToCreative();

let ui = {
 alloy_smelter: null
};

LiquidRegistry.registerLiquid("steam", "Steam", ["steam"]);


let pos = null;
let protation = null;
Block.registerPlaceFunction(BlockID.gtblockmachine, function(coords, item, block, player, region){
    region.setBlock(coords.relative.x, coords.relative.y, coords.relative.z, item.id, item.data);
    
    let playerobject = new PlayerActor(player);
    let rotation = MetaRenderer.getBlockRotation(player, false);
    let tileEntity = TileEntity.getTileEntity(coords.relative.x, coords.relative.y, coords.relative.z);
    if(tileEntity) {
        tileEntity.data.rotation = proration;
    } else {
        pos = coords.relative;
        protation = rotation;
    }
});

MachineDictionary.addToCreative();

Callback.addCallback("tick", function() {
// playerUid - сущность игрока
// isPlayerDead - дополнительный параметр - мертв ли данный игрок
        if(!pos) return;
        let tileEntity = TileEntity.getTileEntity(pos.x, pos.y, pos.z);
        if(tileEntity) {
            tileEntity.data.rotation = protation;
            pos = null;
            protation = null;
    }
});

TileEntity.registerPrototype(BlockID.gtblockmachine, {
    useNetworkItemContainer: true,
     defaultValues: {
          //is uses steam instead energy
        isSteam: true,
        rotation: 2,
        put0: null,
        put1: null,
        put2: null,
        put3: null,
        put4: null,
        put5: null,
        pipe: false,
        type: null,
        
        ui: null,
          
        amount: 0,
        steamcomsumption: 0,
          
        isProcess: false,
        original_work_time: 0,
        work_time: 0,
        progress: 0,
          
        /*energy: 0,
        energy_receive: 0,
		last_energy_receive: 0,
	    voltage: 0,
	    last_voltage: 0,*/
			    
		temperatureTickEncouter: 0,
		fuelTickEncounter: 0,
		steamTickEncounter: 0,
		temperature: 20,
	    fuel: 0,
     },
init: function() {
  //if(!this.data.inited) this.data.put = [];
  Logger.Log(this.data.rotation, "hyper");
    let dat = 0;
    for(let m in MachineDictionary.steammachines) {
      let uuu = false;
      let steamobj = MachineDictionary.steammachines[m];
      for(let i = 0; i < steamobj.tier.length; i++) {
      if(this.blockSource.getBlock(this.x, this.y, this.z).data == dat) {
        Logger.Log(dat, "soooli");
        this.data.type = steamobj;
        this.data.tier = i;
        Logger.Log(steamobj.name, "so9ooli");
Logger.Log(steamobj.type, "so8i");
		uuu = true;
        break;
    }
    Logger.Log(dat, "cerr");
    dat++;
      }
      if(uuu) break;
  }
  if(this.data.type != null) {
  Logger.Log(this.data.tier, "syyyk");
  Logger.Log(this.data.type, "sjk");
    Logger.Log(this.data.rotation, "sjk");
    if(this.data.type.type == MachineDictionary.GENERATOR) {
      this.liquidStorage.setLimit("water", 16000);
      this.liquidStorage.setLimit("steam", 16000);
      this.liquidStorage.setLimit("lava", 16000);
    } else {
      this.liquidStorage.setLimit("water", 0);
      this.liquidStorage.setLimit("lava", 0);
      this.liquidStorage.setLimit("steam", 16000);
    }
    //this.data.rotation = PipeNetBuilder.;
    Logger.Log(this.data.rotation, "lev");
    Logger.Log({x: this.x, y: this.y, z: this.z}, "levis");
    Logger.Log(this.data.put0, "lev");
    Logger.Log(this.data.put1, "lev");
    Logger.Log(this.data.put2, "lev");
    Logger.Log(this.data.put3, "lev");
    Logger.Log(this.data.put4, "lev");
    Logger.Log(this.data.put5, "levj");
    Logger.Log(this.data.type.textures, "levoiki");
    
this.sendPacket("gtmachine_rotate", {block: {x: this.x, y: this.y, z: this.z}, rotation: this.data.rotation, put0: this.data.put0, put1: this.data.put1, put2: this.data.put2, put3: this.data.put3, put4: this.data.put4, put5: this.data.put5, textures: this.data.type.textures, rotationOfBlock: this.data.rotation});
    //this.sendPacket("gtmachine_ui", {ui: this.data.type.ui});
    this.data.inited = true;
    }
    
    
    
    Logger.Log(this, "fui");
    this.data.pipeEncounter = 0;
			this.__Nets = {};
			TileEntityRegistry.addMacineAccessAtCoords(this.x, this.y, this.z, this);
			for(let name in this.__Types) {
			  PipeNetBuilder.rebuild();
			}
    Logger.Log("inited", "hyper");
},
     tick: function(){
         Logger.Log("Ferrumhi");
       if(this.data.type != null) {
           Logger.Log(this.data.type.type , "Fumhi");
           Logger.Log(MachineDictionary.PROCESSING, "Fumhi");
         if(this.data.type.type == MachineDictionary.PROCESSING) {
             Logger.Log("Frumhi");
           /*for(let xx = -1; xx < 2; xx += 2) {
            for(let yy = -1; yy < 2; yy += 2) {
            ipe].rate * PipeDictionary.sizes[this.data.sizePipe]. multiplier) / 4));
            }}}}*/
          /*if(this.container.getGuiContent()) {
               if(this.data.errored) {
                    this.container.getGuiContent().elements["error"] = {type: "image", x: 1000 / 2 - bitmap.getWidth() / 2 + 150, y: UI.getScreenHeight() / 2 - bitmap.getHeight() / 2 + 101, bitmap: "bronze_error", scale: 3};
               } else {
                    this.container.getGuiContent().elements["error"] = null;
               }
          }*/
          if(!this.data.isProcess) {
              Logger.Log(this.data.type.recipes, "ss");
              if(this.data.type.recipes) {
         for(let i in this.data.type.recipes) {
             Logger.Log(i, "seas");
         }
         for(let i in this.data.type.recipes) {
             Logger.Log(i, "sease");
           if(isNaN(i)) continue;
           this.data.i = this.data.type.recipes[i];
           if(!this.data.i.isSteam()) continue;
             if(this.checkInput(this.data.i)) {
               Logger.Log("is", "is");
               if(this.checkOutput(this.data.i)) {
                 
                 if(this.data.tier == 0) {
              this.data.original_work_time = this.data.i.duration * 2;
              this.data.work_time = this.data.original_work_time;
              this.data.steamcomsumption = this.data.i.EUt * 2;
            } else if(this.data.tier == 1) {
              this.data.original_work_time = this.data.i.duration * 2 / 2;
              this.data.work_time = this.data.original_work_time;
              this.data.steamcomsumption = this.data.i.EUt * 2 * 3;
            }
            
            this.input(this.data.i);
            //this.outputSet(this.data.i);
            
            this.liquidStorage.getLiquid("steam", this.data.steamcomsumption);
            if(!this.check(true)) {
                this.data.i = null;
                 continue;
                 
            } else {
                 this.data.errored = false;
                 /*if(this.container.getGuiContent() != null) {
                    this.container.getGuiContent().elements["error"] = null;
                 }*/
            }
            this.data.isProcess = true;
            this.data.progress += 1/this.data.original_work_time;
            this.container.setScale("scale", this.data.progress);
	    //SoundApi
	    sounds[this.data.type.name + "_sound"].setInBlock(this.x, this.y, this.z, 10);
	        this.sendPacket("gtmachine_soundStart", {sound: sounds[this.data.type.name + "_sound"]});
            //sounds[this.data.type.name + "_sound"].play();
            break;
               }
             }
         }
         
              } else {
                  //if(this.checkInput(this.data.i)) {
                      if(RecipeDictionary.provideFurnaceRecipe(input)) {
                          if(this.checkOutputF(RecipeDictionary.provideFurnaceRecipe(input))) {
                    this.data.isProcess = true;
                 if(this.data.tier == 0) {
              this.data.original_work_time = 256;
              this.data.work_time = this.data.original_work_time;
              this.data.steamcomsumption = 8;
            } else if(this.data.tier == 1) {
              this.data.original_work_time = 128;
              this.data.work_time = this.data.original_work_time;
              this.data.steamcomsumption = 24;
            }
            this.inputF(RecipeDictionary.provideFurnaceRecipe(input));
            //this.outputSet(this.data.i);
            this.data.i = RecipeDictionary.provideFurnaceRecipe(input);//()
            this.liquidStorage.getLiquid("steam", this.data.steamcomsumption);
            if(!this.check(true)) {
                 this.data.i = null;
            } else {
                 this.data.errored = false;
                 /*if(this.container.getGuiContent() != null) {
                    this.container.getGuiContent().elements["error"] = null;
                 }*/
            }
            this.data.progress += 1/this.data.original_work_time;
            this.container.setScale("scale", this.data.progress);
	    //SoundApi
	    sounds[this.data.type.name + "_sound"].setInBlock(this.x, this.y, this.z, 10);
	        this.sendPacket("gtmachine_soundStart", {sound: sounds[this.data.type.name + "_sound"]});
            //sounds[this.data.type.name + "_sound"].play();
                        }
                      }
                  //}
              }
         } else {
           if(this.data.type.recipes) {
           if(this.data.work_time > 0) {
             this.liquidStorage.getLiquid("steam", this.data.steamcomsumption);
             if(!this.check()) return;
             this.data.progress += 1/this.data.original_work_time;
              this.data.work_time -= 1;
              this.container.setScale("scale", this.data.progress);
           } else {
               this.sendPacket("gtmachine_soundEnd", {sound: sounds[this.data.type.name + "_sound"]});
             this.output(this.data.i);
             this.data.progress = 0;
             this.container.setScale("scale", 0);
             
             this.data.isProcess = false;
             this.data.original_work_time = 0;
             //this.clearPut(this.data.i);
             this.data.steamcomsumption = 0;
             let yuki_onna = 0;
             for(let i = 1; i < 6; i++) {
                    if(this.data["put" + i] === null || this.data["put" + i] === undefined) continue;
                   yuki_onna = i;   
             }
             let relative = PipeNetBuilder.getRelativeCoords(this.x, this.y, this.z, this.data["put" + yuki_onna]);
                Particles.addParticle("steam", this.x + relative.x, this.y + relative.y, this.z + relative.z, 0, 0.5, 0);
                this.sendPacket("gtmachine_sound", {sound: sounds["interrupt"]});
           }
         } else {
             if(this.data.work_time > 0) {
             this.liquidStorage.getLiquid("steam", this.data.steamcomsumption);
             if(!this.check()) return;
             this.data.progress += 1/this.data.original_work_time;
              this.data.work_time -= 1;
              this.container.setScale("scale", this.data.progress);
           } else {
               this.sendPacket("gtmachine_soundEnd", {sound: sounds[this.data.type.name + "_sound"]});
             this.outputF(this.data.i);
             this.data.progress = 0;
             this.container.setScale("scale", 0);
             
             this.data.isProcess = false;
             this.data.original_work_time = 0;
             //this.clearPut(this.data.i);
             this.data.steamcomsumption = 0;
             let yuki_onna = 0;
             for(let i = 1; i < 6; i++) {
                    if(this.data["put" + i] === null || this.data["put" + i] === undefined) continue;
                   yuki_onna = i;
                   break;
             }
             if(yuki_onna > -1) {
                 //юки онна!
                 let relative = PipeNetBuilder.getRelativeCoords(this.x, this.y, this.z, this.data["put" + yuki_onna]);
                Particles.addParticle("steam", this.x + relative.x, this.y + relative.y, this.z + relative.z, 0, 0.5, 0);
             } else {
                this.sendPacket("gtmachine_sound", {sound: sounds["interrupt"]});
             }
           }
         }
             
         }
              } else if(this.data.type.type == MachineDictionary.GENERATOR) {
                  if(this.liquidStorage.getAmount("water") + 1000 <= this.liquidStorage.getLimit("water") & this.container.getSlot("inputCan0").id == 325 & this.container.getSlot("inputCan0").data == 8 & this.container.getSlot("inputCan0").count > 0) {
                    if(this.container.getSlot("outputCan0").id == 0 || (this.container.getSlot("outputCan0").id == 325 & this.container.getSlot("outputCan0").count < Item.getMaxStack(325))) {
                  this.container.setSlot("inputCan0", 325, this.container.getSlot("inputCan0").count - 1, 8);
                  if(this.data.temperature > 100) {
                    this.blockSource.explode(this.x, this.y, this.z, 5, false);
                    this.container.close();
                    return;
                  }
                  this.liquidStorage.addLiquid("water", 1000);
                  this.container.setScale("waterScale", this.liquidStorage.getRelativeAmount("water"));
                  if(this.container.getSlot("outputCan0").id == 0 || this.container.getSlot("outputCan0").id == 325) {
                  this.container.setSlot("outputCan0", 325, this.container.getSlot("outputCan0").count + 1, 0);
                  }
                }}
                this.container.validateSlot("inputCan0");
                if(this.data.type.name == "solar_boiler") {
                if(this.data.solarTickEncounter < 255) {
                  this.data.solarTickEncounter++;
                } else {
                  this.data.solarTickEncounter = 0;
                  if(this.dimension == Native.Dimension.NORMAL && this.blockSource.canSeeSky(this.x, this.y + 1, this.z) && OreDictionary.isInnerDiapozone(World.getWorldTime(), 0, 12000)) {
                  this.data.fuel += 8;
                  }
                }
                }
                if(this.data.fuelTickEncounter < 11) {
                  this.data.fuelTickEncounter++;
                } else {
                  if(this.data.temperature < 500) {
                    if(this.data.fuel > 0) {
                      this.data.fuel--;
                      this.data.temperature += 1;
                    } else if(this.data.type.name != "solar_boiler") {
                        for(let i in this.data.type.recipes) {
                        let irdata = MaterialDictionary.invdata[this.data.type.recipes[i].inputs[0].form][this.data.type.recipes[i].inputs[0].material.name];
                        let irdata1 = MaterialDictionary.invdata[this.data.type.recipes[i].outputs[0].form][this.data.type.recipes[i].outputs[0].material.name];
                      if(this.container.getSlot("coal0").id == irdata.id && this.container.getSlot("coal0").data == irdata.data && this.container.getSlot("coal0").count > 0) {
                      this.container.setSlot("coal0", irdata.id, this.container.getSlot("coal0").count - 1, irdata.data);
    
                      this.data.fuel = 500;
                      if(Math.random() < 0.33) {
                        if(this.container.getSlot("ash0").id == 0 || this.container.getSlot("ash0").id == irdata1.id && this.container.getSlot("ash0").data == irdata1.data) {
                          this.container.setSlot("ash0", irdata.id, this.container.getSlot("ash0").count + 1, irdata.data);
                        }
                      }
                      this.data.temperature += 1;
                      }
                        }
                      this.container.validateSlot("coal0");
                      this.container.validateSlot("ash0");
                  }
                  
                    this.container.setScale("heatScale", (this.data.temperature - 20) / 480);
                    this.container.setScale("scale", this.data.fuel / 500);
                this.data.fuelTickEncounter = 0;
                }}
                
                if(this.data.temperatureTickEncounter < 44) {
                  this.data.temperatureTickEncounter++;
                } else {
                  if(this.data.temperature > 20) {
                  this.data.temperature -= 1;
                  this.container.setScale("heatScale", (this.data.temperature - 20) / 480);
                  }
                    this.data.temperatureTickEncounter = 0;
                  }
                  
                if(this.data.steamTickEncounter < 24) {
                  this.data.steamTickEncounter++;
                } else {
                  if(this.data.temperature > 100) {
                  if(this.liquidStorage.getAmount("steam") + 150 <= this.liquidStorage.getLimit("steam") & this.liquidStorage.getAmount("water") - 1 >= 0) {
                  this.liquidStorage.getLiquid("water", 1);
                  this.container.setScale("waterScale", this.liquidStorage.getRelativeAmount("water"));
                  
                  this.liquidStorage.addLiquid("steam", 150);
                  this.container.setScale("steamScale", this.liquidStorage.getRelativeAmount("steam"));

                  }}
                  this.data.steamTickEncounter = 0;
              }
          }}
        this.container.sendChanges();
        
        if(this.data.pipeEncounter == 4) {
			  this.data.pipeEncounter = 0;
			for(let name in this.__Types) {
				if(this.isSource(name)) {
					let net = this.__Nets[name];
					if(net) {
					  let src = net.source;
					  //if(canExtract(side, type)
					  this.Еtick(name, src);
					}
				} else {
				}
			}
			} else {
			  this.data.pipeEncounter++;
			}
     },
     
     click: function(id, count, data, coords, player){
        let playerobject = new PlayerActor(player);
       if(this.data.type != null) {
       if(id == 325 & data == 8) {
         playerobject.setCarriedItem(325, 1, 0);
         if(this.data.temperature > 100) {
           this.blockSource.explode(this.x, this.y, this.z, 5, false);
           return true;
         }
         this.liquidStorage.addLiquid("water", 1);
         this.container.setScale("waterScale", this.liquidStorage.getRelativeAmount("water"));
         this.container.invalidateUI();
         return true;
       } else if(id == ItemID.gtmetatool01 && ToolDictionary.types[data].name == "wrench") {
         let item = playerobject.getInventorySlot(playerobject.getSelectedSlot());
         ToolDictionary.damageTool(item);
    Logger.Log(coords.side, "zopp");
    Logger.Log(this.blockRotationToWorldRotation(3), "zoppexiwq");
    if(coords.side != this.blockRotationToWorldRotation(3)) {
      Logger.Log("sneak", Entity.getSneaking(player));
      if(Entity.getSneaking(player) && coords.side != 0 && coords.side != 1) {
      let rotation = MetaRenderer.getBlockRotation(player, false);
      this.data.rotation = rotation;
      
      this.sendPacket("gtmachine_rotate", {block: {x: this.x, y: this.y, z: this.z}, rotation: this.data.rotation, put0: this.data.put0, put1: this.data.put1, put2: this.data.put2, put3: this.data.put3, put4: this.data.put4, put5: this.data.put5, textures: this.data.type.textures, rotationOfBlock: this.data.rotation});
      
      } else {
        //Logger.Log(this.data.put.length);
        if(this.data["put" + this.worldRotationToBlockRotation(coords.side)] == this.worldRotationToBlockRotation(coords.side)) {
          this.data["put" + this.worldRotationToBlockRotation(coords.side)] = null;
        } else {
          this.data["put" + this.worldRotationToBlockRotation(coords.side)] = this.worldRotationToBlockRotation(coords.side);
        }
        //Logger.Log(this.data.put.length);
        
        this.sendPacket("gtmachine_rotate", {block: {x: this.x, y: this.y, z: this.z}, rotation: this.data.rotation, put0: this.data.put0, put1: this.data.put1, put2: this.data.put2, put3: this.data.put3, put4: this.data.put4, put5: this.data.put5, textures: this.data.type.textures, rotationOfBlock: this.data.rotation});
      }
    }
         return true;
       }
       }
    },
    
    events: {
        // события, принимающие пакеты на стороне сервера, в данном случае this -серверный экземпляр, получивший пакет
        
    },
containerEvents: {
// события контейнера на стороне сервера, в данном случае this - серверный экземпляр, получивший пакет
eventName: function(eventData, connectedClient) {
// доступный только здесь метод:
this.container.sendResponseEvent("eventName", someData)
}
},

    getScreenName: function(player, coords) {
        return this.data.type.name + "_" + this.data.type.tier;
    },
    // это событие вызывается на стороне клиента, this в данном случае не определен, по переданному имени, которое вернул метод getScreenName, возвращает окно, которое нужно открыть
    getScreenByName: function(screenName){
Logger.Log(screenName.substring(0, screenName.indexOf("_")), "fear");
Logger.Log(screenName.substring(0, screenName.indexOf("_")), "fealui");
        if(!screenName.substring(screenName.indexOf("_") + 1)) return MachineDictionary.steammachines[screenName.substring(0, screenName.indexOf("_"))].ui0;
        if(screenName.substring(screenName.indexOf("_") + 1)) return MachineDictionary.steammachines[screenName.substring(0, screenName.indexOf("_"))].ui1;
    },


     check: function(error) {
       let checked = true;
       if(this.liquidStorage.getAmount("steam") < this.data.steamcomsumption) {
            checked = false;
          }
          if(!error && !checked) {
              this.data.errored = true;
          if(this.data.tier == 0) {
            /*if(this.container.getGuiContent() != null) {
               this.container.getGuiContent().elements["error"] = {type: "image", x: 1000 / 2 - bitmap.getWidth() / 2 + 150, y: UI.getScreenHeight() / 2 - bitmap.getHeight() / 2 + 101, bitmap: "bronze_error", scale: 3};
            }*/
          } else if(this.data.tier == 1) {
              //this.container.getGuiContent().elements["error"] = {type: "image", x: 1000 / 2 - bitmap.getWidth() + 150, y: UI.getScreenHeight() / 2 - bitmap.getHeight() + 101, bitmap: "steel_error", scale: 3};
                }
              sounds["interrupt"].setInBlock(this.x, this.y, this.z, 10);
              this.sendPacket("gtmachine_sound", {sound: sounds["interrupt"]});
              //sounds.interrupt.play();
              this.data.progress = 0;
              this.container.setScale("scale", 0);
             
              this.data.isProcess = false;
              this.data.original_work_time = 0;
              this.data.work_time = 0;
              this.clearPut();
              this.data.steamcomsumption = 0;
            }
          return checked;
     },
     checkInput: function(j) {
       let checked = true;
         for(let i = 0; i < this.data.type.recipes.maxInputs; i++) {
           let iddata = MaterialDictionary.invdata[j.outputs[i].form][j.outputs[i].material];
              if(this.container.getSlot("input" + i).id == iddata.id & this.container.getSlot("input"+ i).data == iddata.data & this.container.getSlot("input"+ i).extra == iddata.extra & this.container.getSlot("input" + i).count >= iddata.count) {
              
                
              } else {
                checked = false;
              }
                   }
            return checked;
     },
     input: function(j) {
       for(let i = 0; i < this.data.type.recipes.maxInputs; i++) {
              //this.data["input" + i] = j[i];
              let iddata = MaterialDictionary.invdata[j.inputs[i].form][j.inputs[i].material];
              this.container.setSlot(this.container.getSlot("input" + i).id, this.container.getSlot("input" + i).data, this.container.getSlot("input" + i).count - iddata.count, this.container.getSlot("input" + i).extra);
              
              this.container.validateSlot("input" + i);
              
             //this.data["input" + i] = j[i]; 
       }
     },
     inputF: function(j) {
              this.data["input0"] = j;
              this.container.setSlot(this.container.getSlot("input0").id, this.container.getSlot("input0").data, this.container.getSlot("input0").count - j.count, this.container.getSlot("input0").extra);
              
              this.container.validateSlot("input0");
              
             this.data["input0"] = j; 
     },
     checkOutput: function(j) {
       let checked = true;
       for(let i = 0; i < this.data.type.recipes.maxOutputs; i++) {
           let iddata = MaterialDictionary.invdata[j.outputs[i].form][j.outputs[i].material];
            if(this.container.getSlot("output" + i).id == 0 || (this.container.getSlot("output" + i).id == iddata.id & this.container.getSlot("output" + i).data == iddata.data & this.container.getSlot("output" + i).count + iddata.count < Item.getMaxStack(this.container.getSlot("output" + i).id))) {
            } else {
              checked = false;
            }
       }
       return checked;
     },
    checkOutputF: function(j) {
       let checked = true;
            if(this.container.getSlot("output0").id == 0 || (this.container.getSlot("output0").id == j.id & this.container.getSlot("output0").data == j.data & this.container.getSlot("output0").count + j.count < Item.getMaxStack(this.container.getSlot("output0").id))) {
            } else {
              checked = false;
            }
       return checked;
     },
     output: function(j) {
         
       for(let i = 0; i < this.data.type.recipes.maxOutputs; i++) {
           let iddata = MaterialDictionary.invdata[j.outputs[i].form][j.outputs[i].material];
               this.container.setSlot(iddata.id, iddata.data, this.container.getSlot("output" + i).count + iddata.count, iddata.extra);
               this.container.validateSlot("output" + i);
              }
     },
     outputF: function(result) {
               this.container.setSlot(result.id, result.data, this.container.getSlot("output0").count + result.count, result.extra);
               this.container.validateSlot("output0");
     },
     canConnect: function () {
       return true;
     },
     isSource: function() {
        return this.data.type.type; // блок может отдавать энергию
    },
    isGenerator: function() {
        return this.data.type.type; // блок может отдавать энергию и не может принимать
    },
    canReceive: function(side, type) {
      Logger.Log(MachineDictionary.uses[this.data.type], "azas");
        if(MachineDictionary.uses[this.data.type] === MachineDictionary.GENERATOR) return false;
        Logger.Log(MachineDictionary.uses[this.data.type]);
        let rt = this.worldRotationToBlockRotation(side ^ 1);
        if(rt === this.data["put" + rt]) {
          return true; 
        }
        Logger.Log(this.data["put" + rt], "€!!");
      return false;
      // side != 0 выведет true, если сторона любая, кроме нижней.
    },
    canExtract: function(side, type) {
      if(this.data.type.type === MachineDictionary.PROCESSING) return false;
      let rt = this.worldRotationToBlockRotation(side);
      if(rt === this.data["put" + rt]) {
        return true; 
      }
      return false;
        // выведет true при подключении блока для выхода энергии с нижней стороны.
    },
    getCapacity: function(){
        return this.liquidStorage.getLimit("steam"); // установим лимит хранилища энергии в 2 миллиона (2e6 - это способ записи числа 2000000)
    },
    receive: function(type, amount, sidepre) {
        amount = Math.min(amount, this.getCapacity()); // устанавлимаем максимальное количество энергии, которое может принять механизм равным 1000.
        Logger.Log(amount, "zaebok");
        let add = Math.min(amount, this.getCapacity() - this.liquidStorage.getAmount("steam")); // уменьшаем количество энергии, так, чтобы хранилище не переполнялось;
        this.liquidStorage.addLiquid("steam", add); // добавляем энергию в хранилище
        this.data.sidepre = PipeNetBuilder.sideToNeighboring(sidepre);
        return add; // и возвращаем сколько забрали энергии
    },
    Еtick: function(type, src){
        let output = Math.min(this.getCapacity(), this.liquidStorage.getAmount("steam")); // определяем, сколько энергии блок может отдать
        Logger.Log(output, "osmocene");
        this.liquidStorage.addLiquid("steam", src.add(this, output, "steam", {x: this.x, y: this.y, z: this.z}) - output, this.data.sidepre); // прибавляем к хранилищу количество энергии, которое осталось после отправки пакета, и вычитаем сколько отправляли.
        Logger.Log(this.liquidStorage.getAmount("steam"), "ruthenocene");
        //this.data.sidepre = null;
    },
    
    worldRotationToBlockRotation: function (rotation) {
          Logger.Log(this.data.rotation, "@seao");
          if(this.data.rotation == 3) {
            return rotation;
          }
          let e;
          for(let i = 0; i < MetaRenderer.rotationMap[3].length; i++) {
            if(MetaRenderer.rotationMap[3][i] == rotation) e = i;
          }
          return MetaRenderer.rotationMap[this.data.rotation][e];
        },
        blockRotationToWorldRotation: function (rotation) {
          Logger.Log(this.data.rotation, "@sas");
          if(this.data.rotation == 3) {
            return rotation;
          }
      let e;
      for(let i = 0; i < MetaRenderer.rotationMap[this.data.rotation].length; i++) {
        if(MetaRenderer.rotationMap[this.data.rotation][i] == rotation) e = i;
      }
      Logger.Log(e, "@e");
      Logger.Log(MetaRenderer.rotationMap[3][e], "@sashok");
      return MetaRenderer.rotationMap[3][e];
    },
    destroy: function() {
			TileEntityRegistry.removeMachineAccessAtCoords(this.x, this.y, this.z);
			
			PipeNetBuilder.rebuild();
;
    },
    client: {
        load: function() {},
        worldRotationToBlockRotation: function (rotation, rotationOfBlock) {
          Logger.Log(rotationOfBlock, "@seao");
          if(rotationOfBlock == 3) {
            return rotation;
          }
          let e;
          for(let i = 0; i < MetaRenderer.rotationMap[3].length; i++) {
            if(MetaRenderer.rotationMap[3][i] == rotation) e = i;
          }
          return MetaRenderer.rotationMap[rotationOfBlock][e];
        },
        blockRotationToWorldRotation: function (rotation, rotationOfBlock) {
          Logger.Log(rotationOfBlock, "@sas");
          if(rotationOfBlock == 3) {
            return rotation;
          }
      let e;
      for(let i = 0; i < MetaRenderer.rotationMap[rotationOfBlock].length; i++) {
        if(MetaRenderer.rotationMap[rotationOfBlock][i] == rotation) e = i;
      }
      Logger.Log(e, "@e");
      Logger.Log(MetaRenderer.rotationMap[3][e], "@sashok");
      return MetaRenderer.rotationMap[3][e];
    },
        events: {
            // события, принимающие пакеты на стороне клиента, в данном случае this будет клиентским экземпляром, получившим этот пакет
            gtmachine_rotate: function(packetData, packetExtra, connectedClient) {
                // доступный только здесь метод, отправляет пакет конкретному клиенту:
                let rotationmap = [MetaRenderer.rotationMap[packetData.rotation][0], MetaRenderer.rotationMap[packetData.rotation][1], MetaRenderer.rotationMap[packetData.rotation][2], MetaRenderer.rotationMap[packetData.rotation][3], MetaRenderer.rotationMap[packetData.rotation][4], MetaRenderer.rotationMap[packetData.rotation][5]];
                let puts = [this.blockRotationToWorldRotation(packetData.put0, packetData.rotationOfBlock), this.blockRotationToWorldRotation(packetData.put1, packetData.rotationOfBlock), this.blockRotationToWorldRotation(packetData.put2, packetData.rotationOfBlock), this.blockRotationToWorldRotation(packetData.put3, packetData.rotationOfBlock), this.blockRotationToWorldRotation(packetData.put4, packetData.rotationOfBlock), this.blockRotationToWorldRotation(packetData.put5, packetData.rotationOfBlock)];
                MetaRenderer.invalidateModel({x: this.x, y: this.y, z: this.z}, packetData.block, packetData.textures, rotationmap, puts);
                sounds.wrench.setInBlock(this.x, this.y, this.z, 5);
                sounds.wrench.play();
            },
            gtmachine_put: function(packetData, packetExtra, connectedClient) {
                // доступный только здесь метод, отправляет пакет конкретному клиенту:
                //let texture = MachineDictionary.textures[block.id][block.data].arr;
                let rotationmap = [MetaRenderer.rotationMap[packetData.rotation][0], MetaRenderer.rotationMap[packetData.rotation][1], MetaRenderer.rotationMap[packetData.rotation][2], MetaRenderer.rotationMap[packetData.rotation][3], MetaRenderer.rotationMap[packetData.rotation][4], MetaRenderer.rotationMap[packetData.rotation][5]];
                let puts = [this.blockRotationToWorldRotation(packetData.put0), this.blockRotationToWorldRotation(packetData.put1), this.blockRotationToWorldRotation(packetData.put2), this.blockRotationToWorldRotation(packetData.put3), this.blockRotationToWorldRotation(packetData.put4), this.blockRotationToWorldRotation(packetData.put5)];
                MetaRenderer.invalidateModel({x: this.x, y: this.y, z: this.z}, packetData.block, packetData.textures, rotationmap, puts);
                sounds.wrench.setInBlock(this.x, this.y, this.z, 5);
                sounds.wrench.play();
            },
            gtmachine_sound: function(packetData, packetExtra, connectedClient) {
                packetData.sound.play();
            },
            gtmachine_soundStart: function(packetData, packetExtra, connectedClient) {
                packetData.sound.setLooping(true);
                packetData.sound.play();
            },
            gtmachine_soundEnd: function(packetData, packetExtra, connectedClient) {
                packetData.sound.stop();
            },
            gtmachine_discard: function(packetData, packetExtra, connectedClient) {
                let relative = PipeNetBuilder.getRelativeCoords(this.x, this.y, this.z, this.packetData.put);
                Particles.addParticle("steam", this.x + relative.x, this.y + relative.y, this.z + relative.z, 0, 0.5, 0);
                //packetData.sound.stop();
            },
            gtmachine_ui: function(packetData, packetExtra, connectedClient) {
                //this.ui = packetData.ui;
                //packetData.sound.stop();
            },
            gterror: function() {
                /*if(this.container.getGuiContent() != null) {
                    if(packetData) {
                       this.container.getGuiContent().elements["error"] = {type: "image", x: 1000 / 2 - bitmap.getWidth() / 2 + 150, y: UI.getScreenHeight() / 2 - bitmap.getHeight() / 2 + 101, bitmap: "bronze_error", scale: 3};
                    } else {
                        this.container.getGuiContent().elements["error"] = null;
                    }
                }*/
                let container = new UI.Container();
			    container.openAs(errorimage);
            }
            
        },
        containerEvents: {
            // события клиентского экземпляра контейнера, this не определен
            // эти события предназначены для редактирования содержимого окна
            eventName: function(container, window, windowContent, eventData) {
                // window и windowContent могут быть null
                // Чтобы отправить данные на сервер
                container.sendEvent("eventName", someData)
            }
        }
    }
});

TileEntity.getPrototype(BlockID.gtblockmachine).__energyLibInit = true;
TileEntity.getPrototype(BlockID.gtblockmachine).__Types = {};
TileEntity.getPrototype(BlockID.gtblockmachine).__Nets = {};

Logger.Log(TileEntity.getPrototype(BlockID.gtblockmachine).__Types, "xekror");
	
TileEntityRegistry.addEnergyTypeForId(BlockID.gtblockmachine, "liquid");
 





/*new UI.Window({
     location: {
          x: 0,
          y: 0,
          width: 1000,
          height: UI.getScreenHeight(),
      },
     params: {
          // стилизация (изменение стандартных текстур)
     },
     drawing: [{type: "bitmap", bitmap: "BronzeAlloySmelter", x: 1000 / 2 - bitmap.getWidth(), y: UI.getScreenHeight() / 2 - bitmap.getHeight(), width: bitmap.getWidth() * 2, height: bitmap.getHeight() * 2}],
     elements: {
       "close": {type: "closeButton", global: true, bitmap: "close", bitmap2: "slot", x: 1000 / 2 - bitmap.getWidth(), y: UI.getScreenHeight() / 2 - bitmap.getHeight(), scale: 2},
       "invSlot0": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 14, size: 36, index: 0, bitmap: "slot"},
   "invSlot1": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 36, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 14, size: 36, index: 1, bitmap: "slot"},
      "invSlot2": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 72, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 14, size: 36, index: 2, bitmap: "slot"},
     "invSlot3": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 108, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 14, size: 36, index: 3, bitmap: "slot"},
     "invSlot4": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 144, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 14, size: 36, index: 4, bitmap: "slot"},
     "invSlot5": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 180, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 14, size: 36, index: 5, bitmap: "slot"},
     "invSlot6": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 216, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 14, size: 36, index: 6, bitmap: "slot"},
     "invSlot7": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 252, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 14, size: 36, index: 7, bitmap: "slot"},
     "invSlot8": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 288, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 14, size: 36, index: 8, bitmap: "slot"},
     "invSlot9": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 20, size: 36, index: 9, bitmap: "slot"},
       "invSlot10": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 36, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 20, size: 36, index: 10, bitmap: "slot"},
   "invSlot11": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 72, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 20, size: 36, index: 11, bitmap: "slot"},
      "invSlot12": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 108, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 20, size: 36, index: 12, bitmap: "slot"},
     "invSlot13": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 144, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 20, size: 36, index: 13, bitmap: "slot"},
     "invSlot14": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 180, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 20, size: 36, index: 14, bitmap: "slot"},
     "invSlot15": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 216, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 20, size: 36, index: 15, bitmap: "slot"},
     "invSlot16": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 252, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 20, size: 36, index: 16, bitmap: "slot"},
     "invSlot17": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 288, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 20, size: 36, index: 17, bitmap: "slot"},
     "invSlot18": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 36 - 20, size: 36, index: 18, bitmap: "slot"},
    "invSlot19": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 36, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 36 - 20, size: 36, index: 19, bitmap: "slot"},
        "invSlot20": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 72, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 36 - 20, size: 36, index: 20, bitmap: "slot"},
   "invSlot21": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 108, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 36 - 20, size: 36, index: 21, bitmap: "slot"},
      "invSlot22": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 144, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 36 - 20, size: 36, index: 22, bitmap: "slot"},
     "invSlot23": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 180, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 36 - 20, size: 36, index: 23, bitmap: "slot"},
     "invSlot24": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 216, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 36 - 20, size: 36, index: 24, bitmap: "slot"},
     "invSlot25": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 252, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 36 - 20, size: 36, index: 25, bitmap: "slot"},
     "invSlot26": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 288, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 36 - 20, size: 36, index: 26, bitmap: "slot"},
     "invSlot27": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 36 - 36 - 20, size: 36, index: 27, bitmap: "slot"},
     "invSlot28": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 36, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 36 - 36 - 20, size: 36, index: 28, bitmap: "slot"},
    "invSlot29": {type: "invSlot", x:1000 / 2 - bitmap.getWidth() + 14 +
    72, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 36 - 36 - 20, size: 36, index: 29, bitmap: "slot"},
    "invSlot30": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 108, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 36 - 36 - 20, size: 36, index: 30, bitmap: "slot"},
   "invSlot31": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 144, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 36 - 36 - 20, size: 36, index: 31, bitmap: "slot"},
      "invSlot32": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 180, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 36 - 36 - 20, size: 36, index: 32, bitmap: "slot"},
     "invSlot33": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 216, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 36 - 36 - 20, size: 36, index: 33, bitmap: "slot"},
     "invSlot34": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 252, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 36 - 36 - 20, size: 36, index: 34, bitmap: "slot"},
     "invSlot35": {type: "invSlot", x: 1000 / 2 - bitmap.getWidth() + 14 + 288, y: UI.getScreenHeight() / 2 + bitmap.getHeight() - 36 - 36 - 36 - 36 - 20, size: 36, index: 35, bitmap: "slot"},
       "error": {type: "image", x: 890, y: 890, bitmap: "bronze_error", scale: 1},
       "input0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 68, y: UI.getScreenHeight() / 2 - bitmap.getHeight() + 48, size: 36, bitmap: "slot", needClean: true, isTransparentBackground: true},
       "input1": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 104, y: 
UI.getScreenHeight() / 2 - bitmap.getHeight() + 48, size: 36, bitmap: "slot", needClean: true, isTransparentBackground: true},
    "scale": {type: "scale", x: 1000 / 2 - bitmap.getWidth() + 150, y: UI.getScreenHeight() / 2 - bitmap.getHeight() + 48, direction: 0, bitmap: "bronze_furnace_process", scale: 0 overlay: "текстура", overlayScale: число, overlayOffset: {x: число, y: число}},
        "output0": {type: "slot", x: 1000 / 2 - bitmap.getWidth() + 190, y: UI.getScreenHeight() / 2 - bitmap.getHeight() + 48, size: 36, bitmap: "slot", needClean: true, isTransparentBackground: true},
     },
}));*/
